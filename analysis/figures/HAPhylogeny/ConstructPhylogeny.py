import os
import sys
import argparse

parser = argparse.ArgumentParser("Aligns and formats a multi-FASTA file, then generates a phylogeny.")
parser.add_argument("reference", help="Reference FASTA sequence for the alignment")
parser.add_argument("sequence", help="Sequences to be aligned, in FASTA format")
parser.add_argument("dir", help="Directory to store intermediate files")
args=parser.parse_args()

DIR=args.dir
if(DIR[-1] != "/"):
    DIR=DIR+"/"

# Read a single-sequence FASTA format file and return the sequence.
def ReadFasta(Fasta):
    Sequence = ""
    with open(Fasta,'r') as f:
        line = f.readline()
        while line[0] == '>':
            nextline = next(f)
            while nextline[0] != '>':
                Sequence += nextline.strip('\n')
                try:
                    nextline = next(f)
                except:
                    break
            break
    return Sequence


def main():

    SeqReference = args.reference
    SeqsToAlign = args.sequence

    ReferenceLength = len(ReadFasta(SeqReference))

    FileStem = DIR + (SeqsToAlign.split('.')[0]).rsplit('/')[-1]

    #######################################################################
    # Align each sequence to the reference using needle.
    # Output the file as a FASTA format file in the directory alignments.
    # For n sequences, the alignment file will consist of n aligned pairs,
    # where the first sequence in each pair is the reference.
    #######################################################################

    SeqsAligned = FileStem + "-aligned.fasta"
    if not os.path.exists(SeqsAligned):
        try:
            os.system('needle -asequence %s -bsequence %s '
                      '-gapopen 10.0 -gapextend 0.5 '
                      '-outfile %s -aformat fasta' %
                      (SeqReference, SeqsToAlign, SeqsAligned))
        except:
            print("Alignment error.")
    print("Query sequences aligned.")

    ########################################################################
    # Read in the aligned sequences, one pair at a time.
    # Rename the sequences to eliminate problematic characters.
    # Trim leading and trailing sequence from query sequences
    # and eliminate sequences with indels relative to the reference.
    ########################################################################

    SeqsMAligned = FileStem + "-maligned.fasta"
    SequenceCounter = 0
    with open(FileStem + "-annotations.data", 'w') as meta:
        with open(SeqsMAligned, 'w') as out:
            # Read in the aligned sequences, one pair at a time.
            # Do not read the entire file into memory.
            # First tally the number of sequences in each year.
            with open(SeqsAligned, 'r') as f:

                RefSeq = ""
                RefName = ""
                QuerySeq = ""
                QueryName = ""

                line = f.readline()
                while line[0] == '>':

                    # Store the reference sequence.
                    RefName = line.strip('\n')
                    try:
                        nextline = next(f)
                    except:
                        break
                    while nextline[0] != '>':
                        RefSeq += nextline.strip('\n')
                        nextline = next(f)

                    # Store the query sequence.
                    QueryName = nextline.strip('\n')
                    nextline = next(f)
                    while nextline[0] != '>':
                        QuerySeq += nextline.strip('\n')
                        try:
                            nextline = next(f)
                        except:
                            break

                    # Parse the name of the query sequence to determine its year of origin.
                    QueryYear="unknown"
                    try:
                        QueryYear = (((QueryName.split(" ")[0]).split('/')[3]))
                        if len(QueryYear) < 4:
                            QueryYear = "20" + QueryYear
                        elif len(QueryYear) > 4:
                            QueryYear = QueryYear[0:4]
                    except:
                        continue

                    # Parse the name of the query sequence to determine strain name.
                    # Save it only if it is of the form "patientX"
                    QueryStrain=str(SequenceCounter)
                    try:
                        QueryStrain = (QueryName.split(" ")[0]).split('/')[2]
                        if QueryStrain[0:7] != "patient":
                            QueryStrain=str(SequenceCounter)
                    except:
                        continue


                    # Trim leading and trailing sequence that can be generated by
                    # the inclusion of noncoding regions in the FASTA sequence downloads.
                    # Count the bases in the reference alignment that correspond to excess sequence
                    # and trim them from both sides of the query sequence.
                    TrimStart = 0
                    TrimEnd = 0
                    for i in range(len(RefSeq)):
                        if (RefSeq[i] == "-"):
                            TrimStart += 1
                        else:
                            break
                    for i in range(len(RefSeq)):
                        if (RefSeq[-(i + 1)] == "-"):
                            TrimEnd += 1
                        else:
                            break
                    RefSeq = RefSeq[TrimStart:len(RefSeq) - (TrimEnd)]
                    QuerySeq = QuerySeq[TrimStart:len(QuerySeq) - (TrimEnd)]

                    # If the sequence still seems to have indels relative to the reference sequence,
                    # then discard it, because the excess sequences may cause spurious similarities.
                    # Otherwise, output the query sequences with reconfigured names.
                    # Also require that sequences come from unpassaged clinical samples,
                    # i.e. those whose passage history is marked "unpassaged", "original", or "p0".
                    # Allow sequences that are marked as reference, i.e. Brisbane/2007
                    # and Wisconsin/2005.
                    QueryName=QueryName.replace(" ","")
                    QueryNameShort = ((QueryName.split("|")[0]).split(">")[1])
                    PassageHistory=(QueryName.split("|")[-1]).upper()
                    if len(QuerySeq) == ReferenceLength and \
                            (PassageHistory in ["UNPASSAGED","ORIGINAL","P0","REFERENCE"]):
                        out.write(">%s_%s\n" % ((QueryStrain, QueryYear)))
                        out.write("%s\n" % QuerySeq)
                        meta.write("%s_%s\t%s\t%s\t%s\n" %
                                   (QueryStrain, QueryYear, QueryNameShort, QueryName, PassageHistory))
                        SequenceCounter += 1
                    else:
                        print("Sequence removed due to indels or passage history.")

                    # Clear the current ref and query sequences.
                    # Continue reading the file.
                    RefSeq = ""
                    QuerySeq = ""
                    line = nextline

    #######################################################################
    # Use RAxML to create a tree from the subsampled sequences.
    #######################################################################

    if not os.path.exists("RAxML_info." + FileStem + "-maligned"):
        try:
            os.system('raxmlHPC-SSE3 -s %s -n %s -m GTRCAT -p 1' %
                      (SeqsMAligned, SeqsMAligned.split("/")[-1]))
        except:
            print("Tree error.")
    print("Tree built.")

    print("Hello world!")



if __name__ == '__main__':
    main()